import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { get } from 'svelte/store';

/**
 * @param {number[][]} candidates 
 * @returns {Array<{idx: number, value: number}>}
 */
function nakedSingle(candidates) {
    const moves = [];
    candidates.forEach((cand, idx) => {
        if (cand.length === 1) {
            moves.push({ idx, value: cand[0] });
        }
    });
    return moves;
}

/**
 * @param {number[][]} candidates 
 * @returns {Array<{idx: number, value: number}>}
 */
function hiddenSingle(candidates) {
    const moves = [];

    // Helper function to check a unit (row, column, or box)
    const checkUnit = (unitIndices) => {
        for (let num = 1; num <= SUDOKU_SIZE; num++) {
            const occurrences = [];
            for (const idx of unitIndices) {
                if (candidates[idx].includes(num)) {
                    occurrences.push(idx);
                }
            }
            if (occurrences.length === 1) {
                const cellIndex = occurrences[0];
                // Ensure it's a "hidden" single, not a naked single already
                if (candidates[cellIndex].length > 1) {
                    // Avoid adding duplicate moves if a hidden single is found in multiple units
                    // (e.g. same cell is a hidden single in its row and its box)
                    if (!moves.some(move => move.idx === cellIndex && move.value === num)) {
                         moves.push({ idx: cellIndex, value: num });
                    }
                }
            }
        }
    };

    // Check rows
    for (let i = 0; i < SUDOKU_SIZE; i++) {
        const rowIndices = [];
        for (let j = 0; j < SUDOKU_SIZE; j++) {
            rowIndices.push(i * SUDOKU_SIZE + j);
        }
        checkUnit(rowIndices);
    }

    // Check columns
    for (let j = 0; j < SUDOKU_SIZE; j++) {
        const colIndices = [];
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            colIndices.push(i * SUDOKU_SIZE + j);
        }
        checkUnit(colIndices);
    }

    // Check boxes
    for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
        for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
            const boxIndices = [];
            for (let i = 0; i < BOX_SIZE; i++) {
                for (let j = 0; j < BOX_SIZE; j++) {
                    boxIndices.push(
                        (boxRow * BOX_SIZE + i) * SUDOKU_SIZE + (boxCol * BOX_SIZE + j)
                    );
                }
            }
            checkUnit(boxIndices);
        }
    }

    return moves;
}


export function getOnePossibleNumber(grid, cellIndex) {
    const usedNumbers = new Set();

    let onePossibleNumber = [];

    const [row, col] = GRID_COORDS[cellIndex];

    // Check row
    for (let k = 0; k < SUDOKU_SIZE; k++) {
        if (grid[row][k] !== 0) {
            usedNumbers.add(grid[row][k]);
        }
    }

    // Check column
    for (let k = 0; k < SUDOKU_SIZE; k++) {
        if (grid[k][col] !== 0) {
            usedNumbers.add(grid[k][col]);
        }
    }

    // Check 3x3 box
    const boxStartRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
    const boxStartCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;

    for (let r_box = boxStartRow; r_box < boxStartRow + BOX_SIZE; r_box++) {
        for (let c_box = boxStartCol; c_box < boxStartCol + BOX_SIZE; c_box++) {
            if (grid[r_box][c_box] !== 0) {
                usedNumbers.add(grid[r_box][c_box]);
            }
        }
    }
    // Determine possible numbers for the current cell
    for (let num = 1; num <= SUDOKU_SIZE; num++) {
        if (!usedNumbers.has(num)) {
            onePossibleNumber.push(num);
        }
    }
    
    return onePossibleNumber;
}

/**
 * @param {number[][]} grid - The Sudoku grid as a 2D array (9x9).
 * @returns {number[][]} - A 1D array of 81 elements, where each element is an array of possible numbers for the corresponding cell.
 */
export function getPossibleNumber(grid) {
    const possiblenumbers = Array.from({ length: GRID_LENGTH }, () => []);

    for (let row = 0; row < SUDOKU_SIZE; row++) {
        for (let col = 0; col < SUDOKU_SIZE; col++) {
            const cellIndex = row * SUDOKU_SIZE + col;

            // If the cell is already filled, its list of possible numbers is empty.
            if (grid[row][col] !== 0) {
                continue;
            }

            possiblenumbers[cellIndex] = getOnePossibleNumber(grid, cellIndex);

        }
    }
    return possiblenumbers;
}

/**
 * 
 * @param {number[][]} grid 
 * @returns {[{idx: number, value: number}, message: string]}
 */
export function possibleNumberSolver(grid) {
    const candidates = getPossibleNumber(grid);

    const nakedMoves = nakedSingle(candidates);
    if (nakedMoves.length > 0) {
        const move = nakedMoves[Math.floor(Math.random() * nakedMoves.length)];
        return [move, ["possibleNumber","nakedSingle"]];
    }

    const hiddenMoves = hiddenSingle(candidates);
    if (hiddenMoves.length > 0) {
        const move = hiddenMoves[Math.floor(Math.random() * hiddenMoves.length)];
        return [move, ["possibleNumber","hiddenMoves"]];
    }

    return null;
}